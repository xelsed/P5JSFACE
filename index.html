<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Face-to-Wavetable 3D Synth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.dom.min.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: #05060a;
      color: #f5f5f5;
      overflow: hidden;
    }

    #app-root {
      display: flex;
      flex-direction: row;
      height: 100vh;
      width: 100vw;
    }

    #canvas-container {
      flex: 1 1 auto;
      position: relative;
    }

    #side-panel {
      width: 320px;
      background: #11131a;
      border-left: 1px solid #272a36;
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow-y: auto;
    }

    .panel-section {
      border-radius: 8px;
      padding: 8px 10px;
      background: #151824;
      border: 1px solid #272a36;
    }

    .panel-section h2 {
      font-size: 13px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #9aa0c2;
      margin-bottom: 4px;
    }

    .panel-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      margin: 2px 0;
    }

    .value {
      font-weight: 600;
      color: #e2e6ff;
    }

    label {
      font-size: 11px;
      color: #c0c4e0;
      display: block;
      margin-bottom: 2px;
    }

    input, select, textarea {
      width: 100%;
      font-size: 11px;
      border-radius: 4px;
      border: 1px solid #343852;
      background: #0f1119;
      color: #f5f5f5;
      padding: 4px 6px;
      outline: none;
    }

    textarea {
      min-height: 80px;
      resize: vertical;
    }

    button {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #3e7cff;
      background: #2752ff;
      color: #f5f5ff;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    #collision-list {
      max-height: 160px;
      overflow-y: auto;
      font-size: 11px;
    }

    #collision-list div {
      display: flex;
      justify-content: space-between;
      margin-bottom: 1px;
    }

    #shortcut-list {
      font-size: 11px;
      line-height: 1.35;
      white-space: pre-line;
    }

    #status-bar {
      font-size: 11px;
      color: #b4b8d9;
    }
  </style>
</head>
<body>
  <div id="app-root">
    <div id="canvas-container"></div>

    <aside id="side-panel">
      <div class="panel-section">
        <h2>Capture</h2>
        <div class="panel-row">
          <span>Status</span>
          <span id="capture-status" class="value">Loading model...</span>
        </div>
        <div class="panel-row">
          <span>Mesh</span>
          <span id="mesh-status" class="value">-</span>
        </div>
        <div class="panel-row">
          <span>View</span>
          <span id="view-status" class="value">Facemesh</span>
        </div>
        <div style="font-size: 11px; margin-top: 4px; color: #c0c4e0;">
          Press <b>C</b> to capture / freeze current face mesh.
        </div>
      </div>

      <div class="panel-section">
        <h2>Slices & Collisions</h2>
        <div class="panel-row">
          <span>Slices</span>
          <span id="slice-count" class="value">0</span>
        </div>
        <div class="panel-row">
          <span>Total collisions</span>
          <span id="collision-total" class="value">0</span>
        </div>
        <div id="collision-list"></div>
        <div style="font-size: 11px; margin-top: 4px; color: #c0c4e0;">
          Adjust slices with <b>[</b> and <b>]</b> and watch per-slice collisions.
        </div>
      </div>

      <div class="panel-section">
        <h2>Processing</h2>
        <label for="smoothing-method">Smoothing method</label>
        <select id="smoothing-method">
          <option value="none">None</option>
          <option value="basic">Basic interpolation</option>
          <option value="ai">AI smoothing (OpenAI)</option>
        </select>

        <label for="openai-key" style="margin-top: 6px;">OpenAI API key</label>
        <input id="openai-key" type="password" placeholder="sk-..." />

        <label for="ai-prompt" style="margin-top: 6px;">AI smoothing prompt</label>
        <textarea id="ai-prompt"></textarea>

        <button id="ai-process-btn" style="margin-top: 6px; width: 100%;" disabled>Process with AI</button>
        <div id="ai-status" style="font-size: 11px; margin-top: 4px; color: #c0c4e0;">AI smoothing idle.</div>
      </div>

      <div class="panel-section">
        <h2>Audio (coming next)</h2>
        <div class="panel-row">
          <span>Pitch</span>
          <span id="pitch-display" class="value">-</span>
        </div>
        <div class="panel-row"><span>Attack</span><span id="adsr-attack" class="value">-</span></div>
        <div class="panel-row"><span>Decay</span><span id="adsr-decay" class="value">-</span></div>
        <div class="panel-row"><span>Sustain</span><span id="adsr-sustain" class="value">-</span></div>
        <div class="panel-row"><span>Release</span><span id="adsr-release" class="value">-</span></div>
      </div>

      <div class="panel-section">
        <h2>Shortcuts</h2>
        <div id="shortcut-list">
C: Capture face
[: Decrease slices
]: Increase slices
V: Toggle view mode
(Soon) Space+1-0: Play slices
(Soon) -/+: Pitch down/up
(Soon) A/D/S/R (+Shift): ADSR
        </div>
      </div>

      <div id="status-bar">Webcam + facemesh starting...</div>
    </aside>
  </div>

  <script>
    // --- Global state ---
    let video;
    let facemeshModel;
    let predictions = [];

    let stabilizedLivePoints = [];
    let frozenMesh = null;

    let sliceCount = 12;
    let rawSlices = [];
    let sliceCollisionCounts = [];
    let totalCollisions = 0;
    let sliceBoundsY = { min: 0, max: 0 };

    let viewMode = "mesh"; // "mesh" | "wavetable" (wavetable view to be added)

    // UI elements
    let elCaptureStatus, elMeshStatus, elViewStatus;
    let elSliceCount, elCollisionTotal, elCollisionList;
    let elStatusBar;
    let elSmoothingMethod, elOpenAIKey, elAIPrompt, elAIButton, elAIStatus;

    function setup() {
      const container = document.getElementById("canvas-container");
      const w = container.clientWidth || window.innerWidth - 320;
      const h = container.clientHeight || window.innerHeight;

      const cnv = createCanvas(w, h, WEBGL);
      cnv.parent("canvas-container");

      pixelDensity(1);

      initUIRefs();
      initAIPromptDefault();

      initVideoAndFacemesh();
    }

    function windowResized() {
      const container = document.getElementById("canvas-container");
      const w = container.clientWidth || window.innerWidth - 320;
      const h = container.clientHeight || window.innerHeight;
      resizeCanvas(w, h);
    }

    function initUIRefs() {
      elCaptureStatus = document.getElementById("capture-status");
      elMeshStatus = document.getElementById("mesh-status");
      elViewStatus = document.getElementById("view-status");

      elSliceCount = document.getElementById("slice-count");
      elCollisionTotal = document.getElementById("collision-total");
      elCollisionList = document.getElementById("collision-list");

      elStatusBar = document.getElementById("status-bar");

      elSmoothingMethod = document.getElementById("smoothing-method");
      elOpenAIKey = document.getElementById("openai-key");
      elAIPrompt = document.getElementById("ai-prompt");
      elAIButton = document.getElementById("ai-process-btn");
      elAIStatus = document.getElementById("ai-status");

      elSliceCount.textContent = String(sliceCount);
    }

    function initAIPromptDefault() {
      const defaultPrompt = [
        "Analyze this facial contour slice data representing X positions and Z depths from a 3D face scan.",
        "Smooth and interpolate it into a musically useful wavetable waveform while preserving the general",
        "contour shape. Return the data as an array of amplitude values normalized between -1 and +1.",
        "Input data: [provide X,Z pairs here]"
      ].join(" ");
      elAIPrompt.value = defaultPrompt;
    }

    function initVideoAndFacemesh() {
      elStatusBar.textContent = "Requesting webcam...";

      video = createCapture(VIDEO, () => {
        elStatusBar.textContent = "Webcam ready. Loading facemesh...";
      });
      video.size(640, 480);
      video.hide();

      facemeshModel = ml5.facemesh(video, () => {
        elCaptureStatus.textContent = "Live tracking";
        elMeshStatus.textContent = "0 faces";
        elStatusBar.textContent = "Facemesh model loaded. Look at the camera and press C to capture.";
      });

      facemeshModel.on("predict", (results) => {
        predictions = results || [];
        elMeshStatus.textContent = predictions.length > 0 ? "1 face" : "0 faces";
        if (predictions.length > 0) {
          const pts = extractPointsFromPrediction(predictions[0]);
          stabilizedLivePoints = stabilizePoints(pts);
        }
      });
    }

    function extractPointsFromPrediction(pred) {
      const raw = pred.scaledMesh || [];
      const points = [];
      for (let i = 0; i < raw.length; i++) {
        const p = raw[i];
        points.push({ x: p[0], y: p[1], z: p[2] });
      }
      return points;
    }

    // Stabilize the 3D point cloud: center, scale, and roughly align eyes horizontally.
    function stabilizePoints(points) {
      if (!points || points.length === 0) return [];

      let cx = 0, cy = 0, cz = 0;
      for (const p of points) {
        cx += p.x;
        cy += p.y;
        cz += p.z;
      }
      cx /= points.length;
      cy /= points.length;
      cz /= points.length;

      let xmin = Infinity, xmax = -Infinity;
      let ymin = Infinity, ymax = -Infinity;
      for (const p of points) {
        const x = p.x - cx;
        const y = p.y - cy;
        if (x < xmin) xmin = x;
        if (x > xmax) xmax = x;
        if (y < ymin) ymin = y;
        if (y > ymax) ymax = y;
      }
      const width = xmax - xmin || 1;
      const height = ymax - ymin || 1;
      const scale = 2.0 / Math.max(width, height); // fit roughly into [-1,1]

      // Estimate head roll using approximate eye landmarks (MediaPipe indices).
      const leftEyeIndex = 33;
      const rightEyeIndex = 263;
      let angle = 0;
      if (points[leftEyeIndex] && points[rightEyeIndex]) {
        const lx = (points[leftEyeIndex].x - cx) * scale;
        const ly = (points[leftEyeIndex].y - cy) * scale;
        const rx = (points[rightEyeIndex].x - cx) * scale;
        const ry = (points[rightEyeIndex].y - cy) * scale;
        angle = Math.atan2(ry - ly, rx - lx);
      }

      const ca = Math.cos(-angle);
      const sa = Math.sin(-angle);

      const out = [];
      for (const p of points) {
        let x = (p.x - cx) * scale;
        let y = (p.y - cy) * scale;
        const z = (p.z - cz) * scale;

        const rx = x * ca - y * sa;
        const ry = x * sa + y * ca;

        out.push({ x: rx, y: ry, z });
      }

      return out;
    }

    function draw() {
      background(5, 6, 10);
      orbitControl();

      // Soft light
      directionalLight(255, 255, 255, 0.4, -0.7, -1);
      ambientLight(40);

      push();
      // Flip Y for more intuitive orientation (positive up)
      scale(200, -200, 200);

      if (viewMode === "mesh") {
        renderMeshView();
      } else {
        renderWavetableViewPlaceholder();
      }

      pop();
    }

    function renderMeshView() {
      // Live tracking as ghosted background
      if (stabilizedLivePoints && stabilizedLivePoints.length > 0) {
        stroke(80, 120, 255, 80);
        strokeWeight(0.01);
        noFill();
        beginShape(POINTS);
        for (const p of stabilizedLivePoints) {
          vertex(p.x, p.y, p.z * 0.7);
        }
        endShape();
      }

      // Frozen mesh
      if (frozenMesh && frozenMesh.length > 0) {
        stroke(255, 255, 255);
        strokeWeight(0.015);
        noFill();
        beginShape(POINTS);
        for (const p of frozenMesh) {
          vertex(p.x, p.y, p.z * 0.7);
        }
        endShape();

        drawSliceLines();
      }
    }

    function drawSliceLines() {
      if (!frozenMesh || rawSlices.length === 0) return;

      const minY = sliceBoundsY.min;
      const maxY = sliceBoundsY.max;
      if (minY === maxY) return;

      const h = maxY - minY;
      for (let i = 0; i < sliceCount; i++) {
        const y = minY + h * (i + 0.5) / sliceCount;
        const collisions = sliceCollisionCounts[i] || 0;
        const hasCollision = collisions > 0;

        const col = hasCollision ? [255, 80, 80] : [80, 255, 140];
        stroke(col[0], col[1], col[2]);
        strokeWeight(0.004);

        const extent = 1.1; // extend across face
        line(-extent, y, 0, extent, y, 0);
      }
    }

    function renderWavetableViewPlaceholder() {
      // Placeholder: show a simple text plane until wavetable 3D view is implemented.
      push();
      rotateX(-Math.PI / 4);
      rotateY(0.3);
      noStroke();
      fill(40, 60, 120);
      plane(1.4, 0.4);
      pop();

      push();
      resetMatrix();
      translate(-width / 2 + 20, -height / 2 + 20, 0);
      fill(230);
      textSize(14);
      text("Wavetable 3D view coming next", 0, 0);
      pop();
    }

    // Slice frozenMesh horizontally and compute per-slice collision counts.
    function recomputeSlices() {
      rawSlices = [];
      sliceCollisionCounts = [];
      totalCollisions = 0;

      if (!frozenMesh || frozenMesh.length === 0) {
        updateCollisionUI();
        return;
      }

      let minY = Infinity, maxY = -Infinity;
      for (const p of frozenMesh) {
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      }
      if (!isFinite(minY) || !isFinite(maxY) || minY === maxY) {
        updateCollisionUI();
        return;
      }

      sliceBoundsY.min = minY;
      sliceBoundsY.max = maxY;

      for (let i = 0; i < sliceCount; i++) {
        rawSlices[i] = [];
      }

      const h = maxY - minY;
      const sliceH = h / sliceCount;

      for (const p of frozenMesh) {
        const idx = Math.max(0, Math.min(sliceCount - 1, Math.floor((p.y - minY) / sliceH)));
        rawSlices[idx].push({ x: p.x, z: p.z });
      }

      for (let i = 0; i < sliceCount; i++) {
        const pts = rawSlices[i];
        sliceCollisionCounts[i] = estimateCollisionsForSlice(pts);
        totalCollisions += sliceCollisionCounts[i];
      }

      updateCollisionUI();
    }

    // Collision heuristic: count how many X buckets contain multiple Z depths.
    function estimateCollisionsForSlice(points) {
      if (!points || points.length === 0) return 0;

      let minX = Infinity, maxX = -Infinity;
      for (const p of points) {
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
      }
      if (minX === maxX) return 0;

      const bins = 64;
      const width = maxX - minX;
      const binSize = width / bins;

      const buckets = new Map();
      for (const p of points) {
        const idx = Math.max(0, Math.min(bins - 1, Math.floor((p.x - minX) / binSize)));
        const key = idx;
        if (!buckets.has(key)) {
          buckets.set(key, [p.z]);
        } else {
          buckets.get(key).push(p.z);
        }
      }

      let collisions = 0;
      const eps = 1e-3;
      for (const [, zs] of buckets.entries()) {
        if (zs.length < 2) continue;
        zs.sort((a, b) => a - b);
        let distinct = 1;
        for (let i = 1; i < zs.length; i++) {
          if (Math.abs(zs[i] - zs[i - 1]) > eps) distinct++;
        }
        if (distinct > 1) collisions++;
      }

      return collisions;
    }

    function updateCollisionUI() {
      elSliceCount.textContent = String(sliceCount);
      elCollisionTotal.textContent = String(totalCollisions);

      elCollisionList.innerHTML = "";
      for (let i = 0; i < sliceCount; i++) {
        const c = sliceCollisionCounts[i] || 0;
        const row = document.createElement("div");
        row.textContent = `Slice ${i + 1}`;
        const span = document.createElement("span");
        span.textContent = c;
        span.style.color = c > 0 ? "#ff7070" : "#7fffd4";
        row.appendChild(span);
        elCollisionList.appendChild(row);
      }
    }

    function keyPressed() {
      if (key === "c" || key === "C") {
        if (stabilizedLivePoints && stabilizedLivePoints.length > 0) {
          frozenMesh = stabilizedLivePoints.map((p) => ({ x: p.x, y: p.y, z: p.z }));
          elCaptureStatus.textContent = "Frozen";
          elStatusBar.textContent = "Frozen mesh captured. Adjust slices with [ and ]";
          recomputeSlices();
        }
      } else if (key === "[") {
        sliceCount = Math.max(2, sliceCount - 1);
        if (frozenMesh) recomputeSlices();
      } else if (key === "]") {
        sliceCount = Math.min(64, sliceCount + 1);
        if (frozenMesh) recomputeSlices();
      } else if (key === "v" || key === "V") {
        viewMode = viewMode === "mesh" ? "wavetable" : "mesh";
        elViewStatus.textContent = viewMode === "mesh" ? "Facemesh" : "Wavetable";
      }
    }
  </script>
</body>
</html>
